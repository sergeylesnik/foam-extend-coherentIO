!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Please read this carefully before usage                                       !
! The code is currently under development.                                      !
! Since the code execution does remove operations, usage is at your own risk.   !
! DATA LOSS CAN OCCUR.                                                          !
! Code bundles time stamp 05.01.2018                                            !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

How OpenFOAM file I/O works
----------------------------
OpenFOAM applications executed in parallel generate a folder for each process
processor0
...
processorXXX
...
processorMAX
where MAX is the maximum number of processes N minus one with 0<XXX<MAX.
All field data (total number of stored filed data F) and meshes are stored in those folders.
For transient runs, every stored time-step (total number stored time steps T) creates a folder with the time name in each processor-folder.
Large parallel simulation runs will create a large number of files with a total file number of at least
N*T*F (total file number in this case)
If the mesh is changing over time, this number will even increase.

A result is a large number of files and a lot of file operations which can be a potential bottleneck for shared resources like a large cluster.

How the tar-mechanism works via RAM-Disk:
-----------------------------------------
- The OpenFOAM application is moved into the RAM-Disk after execution.
- IO operations of OpenFOAM are not changed and applications of OpenFOAM do their IO onto the RAM-Disk.
- Every write operation is detected via the systemCall function and written data is packed via tar to the original case folder in files called processorXXX.tar.
- This procedure is not a direct change of the IO behavior of OpenFOAM. It is a workaround to reduce file number and IO load. The resulting file number is, therefore:
processor0.tar
...
processorXXX.tar
independent of the number of written time steps.
- The tar processes are independent threads executed by each process XXX.


Functionality:
--------------

1.) It can tar all time steps (nice for transient runs)
--- and keep the original data to restart with fixed startTime option again (variant 1A)
--- and keep the original data and save additionally the latest timeStep data to restart with fixed latestTime option again (variant 1B)
--- it can delete the original startTime data and save additionally the latest timeStep data to restart with fixed latestTime option again (variant 1C)
--- it can delete the original startTime and can be set to not store the latestTime step data resulting in empty processorXXX (variant 1D)


2.) It can tar the latest time folder (to reduce the data in the tar files)
--- and keep the original data to restart with fixed startTime option again (variant 2A)
--- and keep the original data and save additionally the latest timeStep data to restart with fixed latestTime option again (variant 2B)
--- it can delete the original startTime data and save additionally the latest timeStep data to restart with fixed latestTime option again (variant 2C)
--- it can delete the original startTime and can be set to not store the latestTime step data resulting in empty processorXXX (variant 2D)

The complete code bundle is divided into three parts:
-----------------------------------------------------
.
├── pisoFoamTar     (instrumented example application pisoFoam) (Code bundle 3)
├── README
├── startTarCase    (so-library) (Code bundle 2)
└── tarSystemCall   (so-library) (Code bundle 1)
- The reason for those three parts is to meet different usage scenarios.

Usage scenarios:
----------------
First usage scenario:
- If you do not need to restart
- Or if you need to restart but you can live with a not very large number of files left for restart purposes
  but transient data is the bottleneck and is stored in the processorXXX.tar files
Result:
- You do not need to instrument any OpenFOAM code
- You only need to compile and use the functionCall so-library tarSystemCall (Code bundle 1)
- You can restart from ordinary processorXXX folders
Valid for variants:
1A, 1B, 1C, 2A, 2B and 2C

Second usage scenario:
- If you need to restart and have to reduce the overall file number as much as possible
Result:
- You need the functionCall so-library tarSystemCall (Code bundle 1)
- You need an OpenFOAM application, which can restart from processorXXX.tar files
  and therefore you have to compile the so-library startTarCase (Code bundle 2)
  and you have to instrument your application of choice (an example is given in Code bundle 3)
Valid for variants:
1D and 2D

Compilation of bundles:
-----------------------
Prerequisites:
- Working OpenFOAM Version from www.openfoam.org
   Tested with 5.0 and Dev Version as well as foam-extend-4.0.
- Make sure, all environment variables are correctly set
   Especially FOAM_USER_LIBBIN and FOAM_USER_APPBIN

Code bundle 1:
--------------
- Step into folder tarSystemCall/
cd tarSystemCall/
- Compile source with
./mymake
or with
wmake libso

Code bundle 2:
--------------
Before we can instrument application from OpenFOAM we need bundle 2
The content is as follows:
startTarCase/
├── findTarTimes.C
├── Make
│   ├── files
│   └── options
├── myclean
├── mymake
├── startTarCase.C
├── startTarCase.H
└── thirdParty
    └── myreadme

- Step into startTarCase/thirdParty and compile a thirdParty library libarchive
  Instructions for compiling this software is given in startTarCase/thirdParty/myreadme
- Now you can compile the so-library for OpenFOAM
- Step into startTarCase/
- Compile source with
./mymake


Code bundle 3:
--------------
This is an example of how an OpenFOAM application can be instrumented with the tar-Restart option
For this purpose pisoFoam is taken from $FOAM_APP/solvers/incompressible/pisoFoam

(e.g. cp -r $FOAM_APP/solvers/incompressible/pisoFoam pisoFoamTar)

The content of pisoFoamTar/ example is as follows:
pisoFoamTar/
├── createFields.H
├── Make
│   ├── files
│   └── options
├── myclean
├── mymake
├── pEqn.H
├── pisoFoamTar.C
├── setStartTarCase.H
└── UEqn.H

- To compile the application step into pisoFoamTar/
- Compile source with
./mymake
or with
wmake

How to instrument an application:
---------------------------------
This example demonstrates how to instrument solver pisoFoam

- Copy the solver and rename it:
cp -r $FOAM_APP/solvers/incompressible/pisoFoam pisoFoamTar
- Step into it:
cd pisoFoamTar/
- Edit content of Make/files
"
pisoFoamTar.C                               <-- new C-source file

EXE = $(FOAM_USER_APPBIN)/pisoFoamTar       <-- new executable and place to save
"
- Edit content of Make/options
"
EXE_INC = \
...
    -I$(LIB_SRC)/sampling/lnInclude \
    -I./../startTarCase/lnInclude           <-- new library include
...
EXE_LIBS = \
    -lsampling \
    -L$(FOAM_USER_LIBBIN) -lstartTarCase    <-- libstartTarCase.so for linking
"
- Rename file
mv pisoFoam.C pisoFoamTar.C
- Create an include file
touch setStartTarCase.H
- Edit this file setStartTarCase.H and put in
"
Foam::startTarCase startTar(args);
"
- Now instrument top level solver with editing file pisoFoamTar.C
"
...
#include "fvOptions.H"
#include "startTarCase.H"                   <-- new include header before main routine
...
#include "setRootCase.H"
#include "setStartTarCase.H"                <-- just behind setRootCase.H! New constructer call setStartTarCase
...
"
That's all
- Compile with
wmake
- If you encounter problems with missing libarchive.so etc...
  expand and set LD_LIBRARY_PATH correctly
export LD_LIBRARY_PATH=<yourpathtothisthirdpartydirectory>/startTarCase/thirdParty/libarchive/build/lib64:$LD_LIBRARY_PATH
or
export LD_LIBRARY_PATH=<yourpathtothisthirdpartydirectory>/startTarCase/thirdParty/libarchive/build/lib:$LD_LIBRARY_PATH

- Then try again with
wclean; wmake

Usage of tar-mechanism / How-to:
-------------------------------------------
- An example of a proper setup of controlDict is given under
/tarMechanismComplete/tarSystemCall/controlDict

- All flags etc are set in the controlDict file
- Usage of tar-mechanism is only possible if
purgeWrite 1;
  is set!
- The subdict tarSystemCall is put in the dictionary functions{}

tarSystemCall
    {
        ...
    }


Description of single options:
type tarSystemCall;                             <-- needs to be set
functionObjectLibs ( "libtarSystemCall.so" );   <-- include of so-library for run-time linking
ramDiskUsage true;                              <-- usage true/false for instrumented code or libraries
pathToRamDisk "/tmp";                           <-- path to your mounted RAM-Disk
                                                    NOTE: during execution the case folder inside /tmp
                                                          will be deleted! e.g. /tmp/cavity_sysCall
pathToOriginalCaseFolder "<absPathTo>/foam/andy-plus/libraries/cavity_sysCall";
                                                <-- This is your absolute path to your original case folder
executeCalls 0();                               <-- Not needed here and is switched of with using 0()
endCalls 1("");                                 <-- Should be always turned on
                                                    turns on the tar-Mechanism at the end of application run
restartData false;                              <-- if false then no field and mesh files for latestTime step in processorXXX/
deleteStartTimeFolders true;                    <-- if true then it deletes starTime folder in processorXXX/
onlyRestartAndDataInTar true;                   <-- if true only latestTime step is backup in processorXXX.tar files
endSyncDataMaster 1("postProcessing");          <-- syncing folders to original case folder like postProcessing
                                                    at the end of the application run
                                                    Note: If this is needed,
                                                          this call of the library should come at last place!
writeSyncDataMaster 1("postProcessing");        <-- syncing folders to original case folder like postProcessing
                                                    at each global write call
writeControl   outputTime;                      <-- usual setup for tar-mechanism call
writeInterval   1;                              <-- usual setup for tar-mechanism call

Setting examples for different variants:
-------------------------------
variant 1A:
...
restartData false;
deleteStartTimeFolders false;
onlyRestartAndDataInTar false;
...

variant 1B:
...
restartData true;
deleteStartTimeFolders false;
onlyRestartAndDataInTar false;
...

variant 1C:
...
restartData true;
deleteStartTimeFolders true;
onlyRestartAndDataInTar false;
...

variant 1D:
...
restartData false;
deleteStartTimeFolders true;
onlyRestartAndDataInTar false;
...



variant 2A:
...
restartData false;
deleteStartTimeFolders false;
onlyRestartAndDataInTar true;
...

variant 2B:
...
restartData true;
deleteStartTimeFolders false;
onlyRestartAndDataInTar true;
...

variant 2C:
...
restartData true;
deleteStartTimeFolders true;
onlyRestartAndDataInTar true;
...

variant 2D:
...
restartData false;
deleteStartTimeFolders true;
onlyRestartAndDataInTar true;
...


Example runs:
-------------------------------
Each OpenFOAM version has two examples.
-- run1: Cavity example with pisoFoam. Start from standard decomposed case.
-- run2: Instrumented pisoFoam -> pisoFoamTar solver. Restart from existing tar-case, writing again more time steps into tar-files.



NOTE AGAIN:
-----------
Since code executes certain rm -rf operations please test carefully.

-------------------------------------------------END----------------------------------------------------------

